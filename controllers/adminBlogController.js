import Blog from '../models/Blog.js';
import User from '../models/User.js';

// Get all auto-generated blogs
export const getAutoGeneratedBlogs = async (req, res) => {
  try {
    const { 
      page = 1, 
      limit = 20, 
      sortBy = 'newest',
      category,
      startDate,
      endDate
    } = req.query;
    
    const skip = (parseInt(page) - 1) * parseInt(limit);
    
    // Build query
    const query = { isAutoGenerated: true };
    
    if (category && category !== 'all') {
      query.category = category;
    }
    
    // Date filter
    if (startDate || endDate) {
      query.createdAt = {};
      if (startDate) query.createdAt.$gte = new Date(startDate);
      if (endDate) query.createdAt.$lte = new Date(endDate);
    }
    
    // Sort options
    let sortOptions = { createdAt: -1 };
    if (sortBy === 'oldest') sortOptions.createdAt = 1;
    if (sortBy === 'popular') sortOptions = { 'analytics.views': -1 };
    
    // Get total count
    const total = await Blog.countDocuments(query);
    
    // Get blogs
    const blogs = await Blog.find(query)
      .sort(sortOptions)
      .skip(skip)
      .limit(parseInt(limit))
      .select('title slug bookDetails user tags category views likes createdAt isAutoGenerated generationType metadata')
      .lean();
    
    // Format response
    const formattedBlogs = blogs.map(blog => ({
      id: blog._id,
      title: blog.title,
      slug: blog.slug,
      bookTitle: blog.bookDetails?.title,
      bookAuthor: blog.bookDetails?.authors,
      userName: blog.user.username,
      userId: blog.user.userId,
      tags: blog.tags,
      category: blog.category,
      views: blog.views || 0,
      likesCount: blog.likes?.length || 0,
      generationType: blog.generationType,
      isAutoGenerated: blog.isAutoGenerated,
      wordCount: blog.metadata?.wordCount || 0,
      responseTime: blog.metadata?.responseTime || 0,
      createdAt: blog.createdAt
    }));
    
    res.json({
      success: true,
      blogs: formattedBlogs,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(total / parseInt(limit)),
        totalItems: total
      },
      stats: {
        totalAutoBlogs: total,
        todayCount: await Blog.countDocuments({
          isAutoGenerated: true,
          createdAt: { $gte: new Date(new Date().setHours(0, 0, 0, 0)) }
        })
      }
    });
  } catch (error) {
    console.error('Error fetching auto-generated blogs:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching auto-generated blogs'
    });
  }
};

// Convert auto-blog to manual (approve it)
export const approveAutoBlog = async (req, res) => {
  try {
    const { blogId } = req.params;
    
    const blog = await Blog.findById(blogId);
    if (!blog) {
      return res.status(404).json({ message: 'Blog not found' });
    }
    
    if (!blog.isAutoGenerated) {
      return res.status(400).json({ message: 'Blog is not auto-generated' });
    }
    
    // Convert to manual blog
    blog.isAutoGenerated = false;
    blog.featured = true; // Optionally feature it
    blog.user.username = 'Approved Contributor'; // Update username if needed
    
    await blog.save();
    
    res.json({
      success: true,
      message: 'Blog approved successfully',
      blog: {
        id: blog._id,
        title: blog.title,
        slug: blog.slug,
        isAutoGenerated: blog.isAutoGenerated,
        featured: blog.featured
      }
    });
  } catch (error) {
    console.error('Error approving blog:', error);
    res.status(500).json({
      success: false,
      message: 'Error approving blog'
    });
  }
};

// Delete auto-generated blog
export const deleteAutoBlog = async (req, res) => {
  try {
    const { blogId } = req.params;
    
    const blog = await Blog.findById(blogId);
    if (!blog) {
      return res.status(404).json({ message: 'Blog not found' });
    }
    
    if (!blog.isAutoGenerated) {
      return res.status(400).json({ message: 'Only auto-generated blogs can be deleted via this endpoint' });
    }
    
    await Blog.deleteOne({ _id: blogId });
    
    res.json({
      success: true,
      message: 'Auto-generated blog deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting auto-blog:', error);
    res.status(500).json({
      success: false,
      message: 'Error deleting blog'
    });
  }
};

// Get auto-blog statistics
export const getAutoBlogStats = async (req, res) => {
  try {
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    
    // Get daily counts for last 30 days
    const dailyStats = await Blog.aggregate([
      {
        $match: {
          isAutoGenerated: true,
          createdAt: { $gte: thirtyDaysAgo }
        }
      },
      {
        $group: {
          _id: {
            year: { $year: '$createdAt' },
            month: { $month: '$createdAt' },
            day: { $dayOfMonth: '$createdAt' }
          },
          count: { $sum: 1 },
          avgViews: { $avg: '$views' },
          avgLikes: { $avg: { $size: '$likes' } }
        }
      },
      { $sort: { '_id.year': 1, '_id.month': 1, '_id.day': 1 } }
    ]);
    
    // Get top categories
    const categoryStats = await Blog.aggregate([
      {
        $match: { isAutoGenerated: true }
      },
      {
        $group: {
          _id: '$category',
          count: { $sum: 1 },
          avgViews: { $avg: '$views' }
        }
      },
      { $sort: { count: -1 } },
      { $limit: 10 }
    ]);
    
    // Get top users (who generated most auto-blogs)
    const userStats = await Blog.aggregate([
      {
        $match: { isAutoGenerated: true }
      },
      {
        $group: {
          _id: '$user.userId',
          username: { $first: '$user.username' },
          count: { $sum: 1 },
          lastActivity: { $max: '$createdAt' }
        }
      },
      { $sort: { count: -1 } },
      { $limit: 20 }
    ]);
    
    res.json({
      success: true,
      stats: {
        totalAutoBlogs: await Blog.countDocuments({ isAutoGenerated: true }),
        todayCount: await Blog.countDocuments({
          isAutoGenerated: true,
          createdAt: { $gte: new Date(new Date().setHours(0, 0, 0, 0)) }
        }),
        dailyStats,
        categoryStats,
        userStats,
        qualityMetrics: {
          avgWordCount: await Blog.aggregate([
            { $match: { isAutoGenerated: true, 'metadata.wordCount': { $exists: true } } },
            { $group: { _id: null, avg: { $avg: '$metadata.wordCount' } } }
          ]).then(res => res[0]?.avg || 0),
          blogsWithBookDetails: await Blog.countDocuments({
            isAutoGenerated: true,
            'bookDetails.title': { $exists: true, $ne: null }
          })
        }
      }
    });
  } catch (error) {
    console.error('Error getting auto-blog stats:', error);
    res.status(500).json({
      success: false,
      message: 'Error getting statistics'
    });
  }
};