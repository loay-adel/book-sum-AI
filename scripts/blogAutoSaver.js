import Blog from '../models/Blog.js';
import { getEnhancedBookDetails } from '../controllers/bookController.js';
import User from '../models/User.js';

class BlogAutoSaver {
  constructor() {
    this.isEnabled = true;
    this.minSummaryLength = 100;
    this.maxDailyAutoBlogs = 50;
  }

  // Check if content is suitable for auto-saving
  isContentSuitable(content, title) {
    if (!content || !title) return false;
    
    if (content.length < this.minSummaryLength) return false;
    
    const sentences = content.split(/[.!?]+/);
    if (sentences.length < 3) return false;
    
    const commonResponses = [
      'sorry', 'cannot', 'unable', 'error', 'failed',
      'لا استطيع', 'عذراً', 'خطأ'
    ];
    
    const lowerContent = content.toLowerCase();
    if (commonResponses.some(word => lowerContent.includes(word))) {
      return false;
    }
    
    return true;
  }

  // Generate a good title from content
  generateTitle(originalTitle, content) {
    if (originalTitle && originalTitle.length > 10) {
      return originalTitle;
    }
    
    const sentences = content.split(/[.!?]+/);
    const firstSentence = sentences[0].trim();
    
    if (firstSentence.length > 20 && firstSentence.length < 100) {
      return firstSentence + (firstSentence.endsWith('.') ? '' : '.');
    }
    
    return `Book Summary: ${originalTitle || 'Untitled'}`;
  }

  // Extract tags from content
  extractTags(content, bookTitle) {
    const tags = new Set();
    
    if (bookTitle) {
      tags.add(bookTitle.toLowerCase().split(' ')[0]);
    }
    
    const commonTags = ['book', 'summary', 'review', 'analysis', 'literature'];
    commonTags.forEach(tag => tags.add(tag));
    
    const words = content.toLowerCase().split(/\s+/);
    const stopWords = new Set(['the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with']);
    
    words.forEach(word => {
      if (word.length > 4 && !stopWords.has(word)) {
        if (Math.random() > 0.7) {
          tags.add(word);
        }
      }
    });
    
    return Array.from(tags).slice(0, 8);
  }

  // Generate categories based on content
  determineCategory(content) {
    const contentLower = content.toLowerCase();
    const categoryKeywords = {
      'Fiction': ['story', 'novel', 'character', 'plot', 'fiction'],
      'Science': ['science', 'research', 'discovery', 'theory', 'scientific'],
      'Business': ['business', 'management', 'leadership', 'strategy', 'market'],
      'Self-Help': ['self', 'help', 'improvement', 'growth', 'success'],
      'Biography': ['life', 'biography', 'autobiography', 'memoir'],
      'History': ['history', 'historical', 'past', 'century', 'war'],
      'Technology': ['tech', 'digital', 'computer', 'software', 'internet'],
      'Philosophy': ['philosophy', 'think', 'thought', 'existential', 'meaning']
    };
    
    for (const [category, keywords] of Object.entries(categoryKeywords)) {
      if (keywords.some(keyword => contentLower.includes(keyword))) {
        return category;
      }
    }
    
    return 'Literature';
  }

  // Check for duplicate content
  async isDuplicateContent(content, title) {
    try {
      const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
      
      const similarBlog = await Blog.findOne({
        $or: [
          { title: { $regex: new RegExp(title.slice(0, 30), 'i') } },
          { content: { $regex: new RegExp(content.slice(0, 100), 'i') } }
        ],
        createdAt: { $gte: sevenDaysAgo }
      });
      
      return !!similarBlog;
    } catch (error) {
      console.error('Error checking duplicate:', error);
      return false;
    }
  }

  // Count today's auto-generated blogs
  async getTodayAutoBlogCount() {
    try {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      const count = await Blog.countDocuments({
        isAutoGenerated: true,
        createdAt: { $gte: today }
      });
      
      return count;
    } catch (error) {
      console.error('Error counting today\'s blogs:', error);
      return 0;
    }
  }

  // Main function to auto-save AI response as blog
  async autoSaveAIResponse({
    aiResponse,
    bookTitle,
    userId = 'auto_system',
    username = 'AI Assistant',
    source = 'user_search',
    originalQuery = '',
    aiModel = 'gpt-4',
    responseTime = 0,
    language = 'en'
  }) {
    try {
      if (!this.isEnabled) return null;
      
      const todayCount = await this.getTodayAutoBlogCount();
      if (todayCount >= this.maxDailyAutoBlogs) {
        console.log('Daily auto-blog limit reached');
        return null;
      }
      
      if (!this.isContentSuitable(aiResponse, bookTitle)) {
        console.log('Content not suitable for auto-saving');
        return null;
      }
      
      if (await this.isDuplicateContent(aiResponse, bookTitle)) {
        console.log('Duplicate content detected, skipping');
        return null;
      }
      
      let bookDetails = null;
      try {
        bookDetails = await getEnhancedBookDetails(bookTitle);
      } catch (error) {
        console.log('Could not fetch book details, using basic info');
        bookDetails = {
          title: bookTitle,
          authors: 'Unknown Author',
          thumbnail: 'https://via.placeholder.com/128x192.png?text=Book+Cover'
        };
      }
      
      const title = this.generateTitle(bookTitle, aiResponse);
      const tags = this.extractTags(aiResponse, bookTitle);
      const category = this.determineCategory(aiResponse);
      
      const blog = new Blog({
        title,
        content: `Summary of "${bookTitle}":\n\n${aiResponse}\n\n---\n\n*This summary was automatically generated by AI.*`,
        aiResponse,
        bookDetails,
        user: {
          userId,
          username
        },
        tags,
        category,
        language,
        isAutoGenerated: true,
        generationType: 'ai_summary',
        source
      });
      
      await blog.save();
      
      console.log(`Auto-saved blog: ${title}`);
      
      if (userId !== 'auto_system') {
        try {
          await User.findOneAndUpdate(
            { userId },
            { 
              $push: { 
                blogPosts: {
                  blogId: blog._id,
                  title: blog.title,
                  timestamp: blog.createdAt
                }
              }
            }
          );
        } catch (userError) {
          // Silently fail
        }
      }
      
      return {
        success: true,
        blogId: blog._id,
        title: blog.title,
        slug: blog.slug,
        message: 'Blog auto-saved successfully'
      };
      
    } catch (error) {
      console.error('Error auto-saving blog:', error);
      return null;
    }
  }
}

// Create singleton instance
const blogAutoSaver = new BlogAutoSaver();
export default blogAutoSaver;